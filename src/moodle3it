#!/usr/bin/env python3
import getpass
import logging
import os
import re
import signal
import sys
import threading
import warnings
from subprocess import call
import atexit

import bs4
import requests
from humanize import naturalsize

shared_files_path = '/usr/share/moodle3it'
if os.path.isdir(shared_files_path):
    sys.path.append(shared_files_path)

from config import END_COLOR, COURSE_COLOR, LINK_COLOR, ERROR_COLOR, WINDOWS, LINUX, WARNING_COLOR
from connection import *
from getch import getch
from utils import color_text
from database import Database

dashboard_url = 'https://moodle.iiit.ac.in/my/'
chunk_size = 100000

resume = threading.Event()
cancel = threading.Event()
kb_interrupt = threading.Event()
downloading = threading.Event()
stdin_fd = sys.stdin.fileno()
old_settings_term = None
# print("LINUX: ", LINUX)
if LINUX:
    import termios
    old_settings_term = termios.tcgetattr(stdin_fd)
# path_to_download = '/home/sriteja/iiit/academics/sem4/'

try:
    MOODLE_USERNAME = os.environ['MOODLE_USERNAME']
    MOODLE_PASSWORD = os.environ['MOODLE_PASSWORD']
    path_to_download = os.path.expanduser(os.environ['MOODLE_FILES_PATH'])
except KeyError:
    print(
        "You can set three environment variables MOODLE_USERNAME, MOODLE_PASSWORD & MOODLE_FILES_PATH in order to avoid typing every time.")
    MOODLE_USERNAME = input("Enter your email id: ")
    MOODLE_PASSWORD = getpass.getpass("Enter your password: ")
    while True:
        path_to_download = input(
            "Enter the path to the directory in which the files have to download: ")
        path_to_download = os.path.expanduser(path_to_download)
        if os.path.isdir(path_to_download):
            break
        print("Sorry the path you given is not a correct path, please try again.")


class ObjectSetup(object):
    pass


page = ObjectSetup()
soup = ObjectSetup()
files = ObjectSetup()
names = ObjectSetup()
courses = ObjectSetup()
database = None

ASK_DOWNLOAD = False
DEBUG = False
MY_SQL = False
SINGLE_PAGE = False
SINGLE_PAGE_LINK = ''

while True:
    if len(sys.argv) > 1:
        if sys.argv[1] == '-a':
            ASK_DOWNLOAD = True
            print("ASK_DOWNLOAD setted")
        elif sys.argv[1] == '-s':
            SINGLE_PAGE = True
            del sys.argv[1]
            if 1 < len(sys.argv):
                SINGLE_PAGE_LINK = sys.argv[1]
            else:
                print("Please provide a valid link")
                raise SystemExit(11)

        elif sys.argv[1] == '-p':
            del sys.argv[1]
            if 1 < len(sys.argv):
                if os.path.isdir(sys.argv[1]):
                    path_to_download = sys.argv[1]
                else:
                    print("Please enter a valid path after option -p")
                    raise SystemExit(10)
            else:
                print("Please provide a path to the argument -p")
                raise SystemExit(8)
        else:
            print(str(sys.argv[1]) + ': Invalid Option')
            raise SystemExit(9)
        del sys.argv[1]
    else:
        break


# def is_downloadable(url):
#     """
#     Does the url contain a downloadable resource
#     """
#     global session
#     h = session.head(url, allow_redirects=True)
#     header = h.headers
#     content_type = header.get('content-type')
#     if 'text' in content_type.lower():
#         return False
#     if 'html' in content_type.lower():
#         return False
#     return True


def is_downloadable(content_type):
    """
    Returns whether the file is downloadable or not from the file's content-type

    :param content_type: content-type of the file header
    :return: True if the file is downloadable else False
    """
    if 'text' in content_type.lower():
        return False
    if 'html' in content_type.lower():
        return False
    return True


def get_filename_from_cd(cd):
    """
    Get filename from content-disposition.

    :param cd: content-disposition of the file header
    :return: file name
    """
    if not cd:
        return None
    name = re.findall('filename=(.+)', cd)
    if len(name) == 0:
        return None
    return re.sub(r'[^\x00-\x7f]', r'', name[0].replace('"', ''))


def create_tables(courses_list):
    """
    Create tables in the database.

    :param courses_list:
    :return: int -- the return code
    :raise: SystemExit
    """

    global database
    try:
        if MY_SQL:
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                c, conn = connection()
                for course in courses_list:
                    c.execute(
                        "create table if not exists {0} (filename varchar(100), link varchar(100))".format(
                            course))
                conn.commit()
        else:
            database.create_course_tables(courses_list)
    except Exception as e:
        print("Looks like there is a problem in creating tables and the problem is {}.".format(e))
        raise SystemExit(6)
    return 0


def make_directories(courses_list):
    """
    Makes courses directories.

    :param courses_list:
    :return: int -- the return code
    """
    os.chdir(path_to_download)
    for course in courses_list:
        if not os.path.isdir(course):
            os.mkdir(course)
            print('Made directory', course)
    return 0


def set_login_data():
    """
    Returns the values required for logging in.
    :returns: the login data.
    """
    global session
    url = 'https://login.iiit.ac.in/cas/login'
    username = MOODLE_USERNAME
    password = MOODLE_PASSWORD
    try:
        pg = session.get('https://login.iiit.ac.in')
    except requests.ConnectionError:
        print('I think you are not connected to internet.')
        raise SystemExit(14)
    sp = bs4.BeautifulSoup(pg.text, 'lxml')
    execution_value = sp.find('input', {'name': 'execution'}).get('value')
    return url, execution_value, username, password


def advanced_login():
    """
    Tries logging in by reconnecting to iiit vpn.

    :return: the login request page
    """
    call(['/bin/bash', '-i', '-c', 'iiit -d'])
    pg = login()
    call(['/bin/bash', '-i', '-c', 'iiit -c'])
    return pg


def connect_to_moodle():
    """
    Tries connecting to moodle.

    :return: int -- the return status
    :raise: SystemExit
    """
    global page
    try:
        pg = session.get('https://moodle.iiit.ac.in/my/')
        print(color_text('Accessed to Moodle', 'green'))
    except requests.ConnectionError:
        print(
            "Looks like you are not connected to iiit vpn, run iiit -c command to connect to iiit vpn")
        raise SystemExit(4)
    return pg


def get_courses():
    """
    Get the course from the Moodle dashboard page.

    :return: int -- the return status
    :raise: SystemExit
    """
    global courses
    for i in courses.html:
        courses.list.append(i.text.replace(' ', '_').replace('-', '').replace('.', ''))
        courses.links.append(i.find('a').get('href'))

    if not courses.list or not courses.html:
        print(
             color_text("Looks like there is some problem in getting moodle dashboard page, try after some time", ERROR_COLOR))
        raise SystemExit(5)
    else:
        print(
            color_text("You are registered to the following courses for this sem", "pink"))
        s = color_text("{:<30}", COURSE_COLOR)
        [print(s_no, ') ', s.format(course), '(', color_text(link, LINK_COLOR), ')', sep='') for
         course, s_no, link in
         zip(courses.list,
             range(1, len(courses.list) + 1),
             courses.links)]
    return 0


def login_test(pg):
    if 'Log In Successful' in pg.text:
        return True


def login():
    """
    Login the user to iiit sites.

    :return: the login request page
    :raise: SystemExit
    """
    global session, soup
    url, execution_value, username, password = set_login_data()
    success_text = 'You, '+MOODLE_USERNAME+', have successfully' \
                   ' logged into the Central Authentication Service.'
    password_expiry_text = "Your password expires in "
    try:
        pg = session.post(url,
                          data={'username': username, 'password': password,
                                'execution': execution_value, '_eventId': 'submit'},
                          timeout=10)
    except requests.ConnectionError as e:
        print("I think you are not connected to internet.")
        print(e)
        raise SystemExit(1)
    except requests.ReadTimeout:
        logging.warning(
            "Looks like CAS is down as it does not support single Sign-Out, try logging out of all other "
            "applications or increase the timeout. But as of now I am trying some advanced method. If you "
            "see this message again and again then stop this program and try after some time.")
        return advanced_login()

    sp = bs4.BeautifulSoup(pg.text, 'lxml')
    setattr(soup, 'login', sp)

    # if sp.find('p').text == success_text:
    if login_test(pg):
        if WINDOWS:
            os.system("cls")
        print(color_text('Login Successful', 'Green'))
        # exit(1)
    elif password_expiry_text in sp.find('p').text:
        print(color_text("Warning: " + sp.find('p').text, WARNING_COLOR))
        print(color_text('Login Successful', 'Green'))
        # soup.find('a', {"class": "button"}).get('href')
        # session.
    else:
        # print(username, password)
        print(pg.text)
        print(sp.find('p').text)
        # print(soup.login)
        print(
            'Login Failure. Try checking credentials or change the execution value. Even if the problem persists try after some time.')
        raise SystemExit(3)
    return pg


def get_links(courses_list, courses_links):
    """
    Get the download links of the files.

    :param courses_list: List of courses for the files to get.
    :param courses_links: The links for the course in the courses_list.
    :return: int -- the return status.
    """
    global soup, page, files, names
    print("Now getting the links of topics in the courses...")
    for course, link in zip(courses_list, courses_links):
        page.temp = session.get(link)
        setattr(page, course, page.temp)
        soup.temp = bs4.BeautifulSoup(getattr(page, course).text, 'lxml')
        setattr(soup, course, soup.temp)
        print(color_text(course, 'brown'), end='...')
        topics = getattr(soup, course).select('.accesshide')
        setattr(files, course, [])
        setattr(names, course, [])
        if DEBUG:
            print(topics)
        for i in topics:
            if i.text == " File":
                getattr(files, course).append(i.find_parent('a').get('href'))
                getattr(names, course).append(i.find_parent('span').find(text=True))
        if not getattr(files, course):
            print("looks like there are no topics in this course.")
        else:
            print("Accessed.")
    return 0


def get_all_courses():
    global session, courses, DEBUG

    link = 'https://moodle.iiit.ac.in/blocks/custom_course_menu/interface.php'
    pg = session.get(link)
    sp = bs4.BeautifulSoup(pg.text, 'lxml')

    if DEBUG:
        print(sp.prettify())
        for i in sp.select('.custom_course_menu_category'):
            print('got')
            print(i.text)
        print()
        for i in sp.select('.custom_course_menu_category')[0]:
            if isinstance(i, bs4.element.NavigableString):
                print(i.strip())
    print()
    color_length = len(COURSE_COLOR + END_COLOR)
    space_fmt = "{:<" + str(color_length + 33) + "}"
    for i in sp.select('.custom_course_menu_category'):
        for j in i:
            if isinstance(j, bs4.element.NavigableString):
                print(color_text(j.strip().replace(' ', '_'), "yellow"))
        for li in i.select('.custom_course_menu_course'):
            print(space_fmt.format(color_text(li.text, COURSE_COLOR)) + '(' + color_text(li.find('a').get(
                'href'), LINK_COLOR) + ')')
        print()

    return


def get_selected_courses():
    """
    Get the selected courses to download files from the user.

    :return: Selected courses by the user along with their moodle courses links.
    """
    print(
        'Select the course you want to update from the above registered courses list by typing the number of the '
        'course. If you want to update multiple courses other than "All Courses" then multiple numbers seperated '
        'by spaces.')
    while True:
        try:
            input_list = list(map(int, input().split()))
        except ValueError:
            print("Invalid Input, please read the above statement")
        else:
            if len(input_list) == 1:
                if not 0 < input_list[0] < len(courses.list) + 2:
                    print("Sorry your input must be in between 0 and", len(courses.list) + 2)
                else:
                    if input_list[0] == len(courses.list) + 1:
                        sel_courses = courses.list
                        sel_courses_link = courses.links
                    else:
                        sel_courses = [courses.list[input_list[0] - 1]]
                        sel_courses_link = [courses.links[input_list[0] - 1]]
                    break

            else:
                for num in input_list:
                    if not 0 < num < len(courses.list) + 1:
                        print("For multiple courses your inputs must be between 0 and",
                              len(courses.list) + 1)
                        break
                else:
                    sel_courses = list(courses.list[x - 1] for x in input_list)
                    sel_courses_link = list(courses.links[x - 1] for x in input_list)
                    break

    return sel_courses, sel_courses_link


def print_downloading_file():
    return


def cancel_download(filename):
    """
    Removes the file and prints cancelled.

    :param filename: Name of the file to remove
    :return: int -- the return status
    """
    print(15 * ' ', 15 * '\b', sep='', end='')
    print('cancelled')
    if os.path.isfile(filename):
        os.remove(filename)
    return


def to_download(filename):
    if ASK_DOWNLOAD:
        print('\r' + 'Are you sure want to download', filename, '?(y/n):', end='')
        go_to_next = False
        while True:
            reply = input()
            if reply == 'y':
                break
            elif reply == 'n':
                go_to_next = True
                break
            else:
                print('Please reply (y/n):', end='')
        if go_to_next:
            return False
        else:
            return True
    return True


def download_from_course(course):
    """
    Download files from the given course.

    :param course: Name of the course to download the files from.
    :return: int -- the return status.
    :raise: SystemExit
    """
    # course = 'Mathematics_II'
    # cur_wor_dir = os.getcwd()
    os.chdir(path_to_download)
    os.chdir(course)
    if MY_SQL:
        c, conn = connection()
    print('\r' + color_text(course, COURSE_COLOR) + ' :')
    for link, name in zip(getattr(files, course), getattr(names, course)):
        if MY_SQL:
            x = c.execute("select filename from {0} where link='{1}'".format(course, link))
        else:
            x, sqlite_fn = database.check_file(course, link)
        if not int(x) > 0:
            # start = time.clock()
            file_headers = session.head(link, allow_redirects=True).headers
            # print(time.clock() - start)
            filename = get_filename_from_cd(file_headers.get('content-disposition'))
            if is_downloadable(file_headers.get('content-type')):
                try:

                    if ASK_DOWNLOAD and not to_download(filename):
                        continue

                    file_size = int(file_headers['content-length'])
                    print('\r', '\t' + color_text(filename, 'cyan'), '(', naturalsize(file_size), ')',
                          ' downloading... ', flush=True, sep='', end='')
                    downloaded = 0
                    downloading.set()
                    # sec_sta = time.clock()
                    resume.wait()
                    if kb_interrupt.isSet():
                        raise KeyboardInterrupt
                    file = session.get(link, stream=True)
                    # print(time.clock() - sec_sta)
                    with open(filename, 'wb') as f:
                        for chunk in file.iter_content(chunk_size):
                            if kb_interrupt.isSet():
                                raise KeyboardInterrupt
                            resume.wait()
                            if cancel.isSet():
                                f.close()
                                cancel_download(filename)
                                cancel.clear()
                                downloading.clear()
                                break
                            if chunk:
                                f.write(chunk)
                                downloaded += len(chunk)
                            downloaded_percentage = int((downloaded / file_size) * 100)
                            print('{0}% Completed'.format(downloaded_percentage),
                                  '\b'.rjust(12 + len(str(downloaded_percentage)), '\b'), end='',
                                  flush=True)
                        else:
                            downloading.clear()
                            if MY_SQL:
                                c.execute(
                                    "insert into {0} (filename, link) values  ('{1}','{2}')".format(
                                        course, filename, link))
                                conn.commit()
                            else:
                                database.insert_file(course, link, filename)
                            print(15 * ' ', 15 * '\b', sep='', end='')
                            print('finished.')

                    file.close()

                except KeyboardInterrupt:
                    # print('cancelled')
                    cancel_download(filename)
                    if MY_SQL:
                        c.execute("delete from {0} where link = '{1}'".format(course, link))
                        conn.commit()
                        c.close()
                    else:
                        database.delete_entry(course, link)

                    file.close()
                    # if os.path.isfile(filename):
                    #     os.remove(filename)
                    raise SystemExit
            else:
                print('\r' + '\t' + name + ' is not downloadable')
        else:
            if MY_SQL:
                filename = c.fetchone()[0]
            else:
                filename = sqlite_fn
            print('\r' + '\t' + color_text(filename, 'cyan') + ' is already downloaded')
    if MY_SQL:
        conn.commit()
        c.close()
    # print("\rFinished downloading files from the course", color_text(course, COURSE_COLOR))
    os.chdir(path_to_download)
    return 0


def download_without_database(course):
    global session
    os.chdir(path_to_download)
    os.chdir(course)

    for link, name in zip(getattr(files, course), getattr(names, course)):
        file_headers = session.head(link, allow_redirects=True).headers
        filename = get_filename_from_cd(file_headers.get('content-disposition'))
        if is_downloadable(file_headers.get('content-type')):
            try:
                if not os.path.isfile(filename):
                    file_size = int(file_headers.get('content-length'))
                    print('\r', filename, '(', naturalsize(file_size), ')',
                          ' downloading... ', flush=True, sep='', end='')
                    downloaded = 0
                    downloading.set()
                    # sec_sta = time.clock()
                    resume.wait()
                    if kb_interrupt.isSet():
                        raise KeyboardInterrupt
                    file = session.get(link, stream=True)
                    # print(time.clock() - sec_sta)
                    with open(filename, 'wb') as f:
                        for chunk in file.iter_content(chunk_size):
                            if kb_interrupt.isSet():
                                raise KeyboardInterrupt
                            resume.wait()
                            if cancel.isSet():
                                cancel_download(filename)
                                cancel.clear()
                                downloading.clear()
                                break
                            if chunk:
                                f.write(chunk)
                                downloaded += len(chunk)
                            downloaded_percentage = int((downloaded / file_size) * 100)
                            print('{0}% Completed'.format(downloaded_percentage),
                                  '\b'.rjust(12 + len(str(downloaded_percentage)), '\b'), end='',
                                  flush=True)
                        else:
                            downloading.clear()
                            print(15 * ' ', 15 * '\b', sep='', end='')
                            print('finished.')

                        file.close()

            except KeyboardInterrupt:
                # print('cancelled')
                cancel_download(filename)
                file.close()
                raise SystemExit
        else:
            print('\r' + name + ' is not downloadable')


def inp():
    """
    Take input from the user while downloading the files.

    :return: int -- the return status
    """
    # exit(12)
    while True:
        # print("dfsdfssfsd")
        c = getch()
        # print(c * 100)
        if downloading.is_set():
            # print(c*10, end='')
            if c == ' ':
                # print('m' * 1000)
                # pause the download
                if resume.is_set():
                    resume.clear()
                else:
                    resume.set()
            elif c == 'c':
                # cancel the running download
                resume.set()
                cancel.set()
        if c == 'q':
            # disable interaction
            break
        elif c == '\x03':
            # when ctrl+c is received
            resume.set()
            kb_interrupt.set()
            break
        elif c == '\x1a':
            # send ctrl+z signal to program
            os.kill(os.getpid(), signal.SIGTSTP)
    return


def get_custom_file(course, link, filename=None):
    os.chdir(path_to_download + course)
    downloaded = 0
    file = session.get(link, stream=True, allow_redirects=True)
    if not filename:
        filename = get_filename_from_cd(file.headers.get('content-disposition'))
    file_size = int(file.headers['content-length'])
    print('\r', filename, '(', naturalsize(file_size), ')',
          ' downloading... ', flush=True, sep='', end='')
    with open(filename, 'wb') as f:
        for chunk in file.iter_content(chunk_size):
            if chunk:
                f.write(chunk)
                downloaded += len(chunk)
            downloaded_percentage = int((downloaded / file_size) * 100)
            print('{0}% Completed'.format(downloaded_percentage),
                  '\b'.rjust(12 + len(str(downloaded_percentage)), '\b'), end='', flush=True)
        print(15 * ' ', 15 * '\b', sep='', end='')
        print('finished.')

    file.close()
    return


def run_engine():
    global session, files, names, database
    setattr(page, 'login', login())
    setattr(page, 'dashboard', connect_to_moodle())
    if SINGLE_PAGE:
        print("Not yet implemented.")
        return
    get_all_courses()

    setattr(soup, 'dashboard', bs4.BeautifulSoup(page.dashboard.text, 'lxml'))
    setattr(courses, 'html', soup.dashboard.select('.course_title'))
    setattr(courses, 'list', [])
    setattr(courses, 'links', [])
    get_courses()
    print(len(courses.list) + 1, ')' + color_text('All Courses', COURSE_COLOR), sep='')

    database = Database("temp.db")
    create_tables(courses.list)
    make_directories(courses.list)
    selected_courses, selected_courses_links = get_selected_courses()
    print()
    # Uncomment the below lines if you want to download files from a specific course.
    # selected_courses = ["Operating_Systems"]
    # selected_courses_links = ["https://moodle.iiit.ac.in/course/view.php?id=1377"]

    setattr(page, 'temp', '')
    setattr(soup, 'temp', '')
    get_links(selected_courses, selected_courses_links)
    print()
    if DEBUG:
        print(files.Operating_Systems, names.Operating_Systems)
    if not ASK_DOWNLOAD:
        # exit(1)
        inp_thread = threading.Thread(target=inp)
        inp_thread.daemon = True
        k = inp_thread.start()
        # print(k)
        # exit(1)
    resume.set()
    for selected_course in selected_courses:
        if DEBUG:
            print('files.' + selected_course + '->', getattr(files, selected_course))
        if getattr(files, selected_course) and getattr(names, selected_course):
            download_from_course(selected_course)
            print()
            # download_without_database(selected_course)
        else:
            print("\r" + color_text(selected_course, COURSE_COLOR) + ' :\n' + '\r\t' + 'No files\n')
            # print("\rNo files or topics in " + color_text(selected_course, COURSE_COLOR) + ' course', '\n')

    print('\r')


def exit_handler():
    global stdin_fd, old_settings_term
    if WINDOWS:
        return
    if LINUX:
        import termios
        termios.tcsetattr(stdin_fd, termios.TCSADRAIN, old_settings_term)


with requests.Session() as session:
    if __name__ == "__main__":
        atexit.register(exit_handler)
        # print(old_settings_term)
        # if LIN
        # print("\033[?1049h\033[H")
        run_engine()
        # sys.stdin.write('')
        # print("Press q and then any key for a safe exit.")
        # getch()
        # print("\033[?1049l")
